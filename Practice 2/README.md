# Практична робота №2 
# Звіт
# Завдання 1
# Програма призначена для визначення моменту часу, коли змінна типу time_t досягне свого максимального значення і переповниться. Вона виводить розмір типу time_t, його граничне значення, а також дату, що відповідає цьому значенню.

Програма є корисною для дослідження проблеми 2038 року (на 32-бітних системах), коли time_t, що представляється як 32-бітне ціле число зі знаком, переповниться і призведе до некоректного представлення часу.

Також програма демонструє різницю між 32- та 64-бітною архітектурою:
- **У 32-бітній системі максимальна дата — 19 січня 2038 року**
- **У 64-бітній системі ця дата знаходиться через мільярди років у майбутньому**
``` bash
yarik@tv-32:~/ASPZ/Practice 2 $ . /task1
Poзmip time_t: 8 байт
Максимальне значення time t: 9223372036854775807
ctime() повернула NULL (некоректне значення часу)
```

# Завдання 2
# У ході виконання завдання було скомпільовано кілька варіантів програм, виміряно їхній розмір командою ls -l та проведено аналіз структури ELF-файлів за допомогою команди size.
# Таблиця результатів:
| Column 1 | Column 2 | Column 3 | Column 4 | Column 5 | Column 6 | Columb 7 | 
|----------|----------|----------|----------|----------|----------|----------|
| Файл  | Розмір (байт)  | .text  | .data | .bss | dec | hex | 
| 2.1  | 8200  | 1079  | 552 | 16 | 1647 | 66F | 
| 2.2  | 8232  | 1079  | 552 | 4032 | 5643 | 161f | 
| 2.3  | 12354  | 1079  | 4544 | 16 | 5663 | 161f |
| 2.4  | 8324  | 1175  | 552 | 16 | 1743 | 6cf | 
| 2.4(-g)  | 9269 | 1175  | 552 | 16 | 1743 | 6cf | 
| 2.4(-OЗ)  | 8167 | 1175  | 552 | 16 | 1685 | 696 | 

# Пояснення:
- **Програма 1
Базовий приклад "Hello, world!", без додаткових змінних. Розмір сегментів .data та .bss мінімальний, .text містить лише основний код.**
- **Програма 2
Додано глобальний масив int array[1000]; без ініціалізації. Це спричинило зростання сегмента .bss на ~4000 байт, але розмір файлу майже не змінився, оскільки .bss не зберігається у виконуваному файлі.**
-**Програма 3
Той самий масив, але з ініціалізацією (= {1}), перемістився до сегмента .data, який зберігається у файлі. Це призвело до збільшення розміру виконуваного файлу.**
-**Програма 4
Додано два великі локальні масиви в окремій функції. Оскільки вони зберігаються у стеку під час виконання, їх не видно в .data чи .bss. Збільшення .text пов'язане з розширенням коду функції.**
-**Налагоджувальна версія (-g)
Файл значно виріс у розмірі (майже на 800 байт), проте розміри сегментів залишилися незмінними. Це пов’язано з додаванням символів налагодження.**
-**Оптимізована версія (-O3)
Розмір .text зменшився через оптимізацію коду. Загальний розмір виконуваного файлу також трохи менший.**

#Висновки:
#Сегмент .bss не зберігається у виконуваному файлі, а лише описує обсяг пам’яті, який потрібно виділити під час запуску програми. Натомість сегмент .data зберігається у файлі, тому ініціалізація глобальних змінних безпосередньо впливає на його розмір. Розмір сегмента .text змінюється залежно від обсягу коду та використаних оптимізацій. Локальні змінні, навіть великі, не впливають на розміри ELF-сегментів, оскільки розміщуються у стеку під час виконання. Налагоджувальна компіляція додає до файлу службову інформацію для дебагу, що значно збільшує загальний розмір виконуваного файлу, хоча не змінює розміри основних сегментів.

# Завдання 3
# Дослідження розміщення сегментів пам’яті процесу
``` bash
The stack top is near 0x820636aac
yar i k @t v - 32: ~/ ASPZ/ Practice 2 $ . / task 3. 2
Text ( code) :
Global ( . data) :
Static ( . data) :
Const ( . rodata) :
Uninit ( . bss) :
Local ( stack) :
Heap ( mal l oc) :

0x400612 ( mai n )
0 x 401 a 90
0 x 401 a 94
0 x 4 0 0 6 e 8
0 x 4 01 a a 4
0 x 820 e 1 d1 e 4
0 x 19 c 9 b 6 a 0 8008
```
## Стек росте вниз
## Купа росте вгору

# Завдання 4
# Вивід програми
``` bash
admin@FreeBSD:~/ASPZ/practice2 $ gcc 4.c -o 4
admin@FreeBSD:~/ASPZ/practice2 $ ./4
In function                main; &localvar = 0x28132d77c
In function                 foo; &localvar = 0x28132d74c
In function                 bar; &localvar = 0x28132d72c
In function   bar_is_now_closed; &localvar = 0x28132d70c

 Now blocking on pause()...
```
# Вивід GDB
```bash
admin@FreeBSD:~/ASPZ/practice2 $ pgrep 4
1955

admin@FreeBSD:~/ASPZ/practice2 $ gdb --quiet -p 1955
Attaching to process 1955
Reading symbols from /home/admin/ASPZ/practice2/4...
Reading symbols from /lib/libc.so.7...
Reading symbols from /usr/lib/debug/lib/libc.so.7.debug...
Reading symbols from /libexec/ld-elf.so.1...
Reading symbols from /usr/lib/debug/libexec/ld-elf.so.1.debug...
Reading symbols from /usr/src/lib/libc/gen/pause.c:51...

(gdb) bt
#0  0x00000008004ab436 in __pause () at /usr/src/lib/libc/gen/pause.c:51
#1  0x00000000004012fa in bar_is_now_closed () at 4.c:9
#2  0x00000000004012db in bar () at 4.c:15
#3  0x00000000004012bc in foo () at 4.c:21
#4  0x000000000040129d in main () at 4.c:27
```

# Завдання 5
# Hеможливо повністю обійтися без лічильника команд, навіть якщо процесор використовує стек для викликів і повернень із процедур, оскільки IP виконує критичну функцію — вказує адресу наступної інструкції для виконання. Під час виклику функції її адреса копіюється в IP, а поточне значення IP зберігається у стеку. При поверненні з функції ця адреса виймається зі стека і знову записується в IP, але сам по собі стек не може "керувати виконанням" без IP, бо не може автоматично змінювати напрям виконання команд. Тому вершина стека може лише зберігати дані для повернення, але не замінює IP як механізм переходу між інструкціями.

# Завдання 6(варіант 6)
# Визначте мінімально необхідний стек для виконання глибокої рекурсії.
``` bash
yarik@tv-32:~/ASPZ/Practice 2 $./task6
write failed, filesystem is full
Segmentation fault
```
