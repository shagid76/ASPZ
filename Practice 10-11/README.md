# Практична робота №10-11 
# Звіт
# Завдання 1
DumbSH
# Реалізація
Програма реалізує найпростішу командну оболонку shell, яка зчитує введення користувача, створює новий процес за допомогою fork() і виконує введену команду через execlp(). Користувачеві виводиться запрошення dumbsh>, після чого вводиться команда. Введений рядок очищується від символу нового рядка, і якщо це слово exit, програма завершується. Інакше створюється дочірній процес, у якому за допомогою execlp() виконується введена команда без параметрів. Якщо виконання не вдалось, виводиться повідомлення про помилку. Батьківський процес чекає завершення дочірнього, використовуючи wait(), і продовжує роботу. Таким чином реалізовано базовий цикл інтерпретатора команд без підтримки аргументів чи розширених можливостей.
```bash
yarik@FreeBSD:~/ASPZ/Practice 10-11 gcc task1.c -o task1
yarik@FreeBSD:~/ASPZ/Practice 10-11 ./task1
dumbsh> ls
task1  task1.c
dumbsh> whoami
root
dumbsh> exit
yarik@FreeBSD:~/ASPZ/Practice 10-11
```
# Завдання 2
API wait
# Реалізація
Моя програма показує, як за допомогою функції wait() можна дочекатися завершення дочірнього процесу. Змінна status зберігає інформацію про те, як саме завершився процес. Коли викликається wait(&status), батьківський процес чекає, поки завершиться один із дочірніх, і повертає його PID. Потім програма перевіряє, чи процес завершився нормально, використовуючи WIFEXITED(status). Якщо все ок, то WEXITSTATUS(status) дозволяє дізнатися, з яким кодом завершився процес, і цей код виводиться на екран.
```bash
yarik@FreeBSD:~/ASPZ/Practice 10-11 gcc task2.c -o task2 
yarik@FreeBSD:~/ASPZ/Practice 10-11 ./task2 
Exited with code 0
```
# Завдання 3
Приклад створення кількох дітей
# Реалізація
Ця програма створює три дочірні процеси у циклі, і кожен з них виводить повідомлення з номером, переданим через змінну i. Після створення всіх дочірніх процесів батьківський процес чекає на завершення кожного з них, використовуючи цикл while (wait(NULL) > 0);.
```bash
yarik@FreeBSD:~/ASPZ/Practice 10-11 gcc task3.c -o task3
yarik@FreeBSD:~/ASPZ/Practice 10-11 ./task3
Child 0
Child 1
Child 2
yarik@FreeBSD:~/ASPZ/Practice 10-11
```
# Завдання 4
У циклі створіть 5 дочірніх процесів. Кожен з них має вивести свій номер та завершитись. Батьківський процес чекає завершення всіх.
# Реалізація
Моя програма створює п’ять дочірніх процесів за допомогою циклу for і чекає, поки всі вони завершаться. На кожній ітерації викликається fork(), і якщо поточний процес — дочірній (child_pid == 0), він виводить повідомлення на екран із номером створення та одразу завершується через exit(0). Це гарантує, що кожна дитина виконує лише свою частину й не продовжує створювати нових процесів.
У батьківському процесі, після створення всіх п’яти дочірніх, йде другий цикл, який п’ять разів викликає wait(NULL), щоб дочекатися завершення кожного з дітей. Коли всі дочірні процеси завершилися, батьківський виводить підсумкове повідомлення: All child processes have finished. Програма демонструє базові принципи роботи з багатопроцесністю в Unix-подібних системах: створення процесів через fork(), обробка помилок, завершення дочірніх процесів і синхронізація за допомогою wait().
```bash
yarik@FreeBSD:~/ASPZ/Practice 10-11 gcc task4.c -o task4
yarik@FreeBSD:~/ASPZ/Practice 10-11 ./task4
Child process 1
Child process 2
Child process 3
Child process 4
Child process 5
All child processes have finished.
yarik@FreeBSD:~/ASPZ/Practice 10-11
```
