# Практична робота №8 
# Звіт
# Завдання 1
Чи може виклик count = write(fd, buffer, nbytes); повернути в змінній count значення, відмінне від nbytes? Якщо так, то чому? Наведіть робочий приклад програми, яка демонструє вашу відповідь.
# Реалізація
Програма демонструє, що виклик write() може повернути кількість записаних байтів, меншу за запитані. Створюється неблокуючий канал (pipe) і в нього записуються дані фіксованими блоками до повного заповнення буфера. Після цього виконується ще одна спроба запису, яка завершується з помилкою EAGAIN, що свідчить про те, що буфер повний і записати нові дані неможливо без блокування. Таким чином, програма ілюструє можливість часткового або нульового запису при використанні неблокуючих дескрипторів.
 ```bash
yarik@FreeBSD:~/ASPZ/Practice 8 $ gcc -Wall task1.c -o task1
yarik@FreeBSD:~/ASPZ/Practice 8 $ ./task1
Записано у pipe до заповнення: 65536 байт
Друге write(): буфер повний, записано 0 байт (EAGAIN)
```
# Завдання 2
Є файл, дескриптор якого — fd. Файл містить таку послідовність байтів: 4, 5, 2, 2, 3, 3, 7, 9, 1, 5. У програмі виконується наступна послідовність системних викликів:
lseek(fd, 3, SEEK_SET);
read(fd, &buffer, 4);
де виклик lseek переміщує покажчик на третій байт файлу. Що буде містити буфер після завершення виклику read? Наведіть робочий приклад програми, яка демонструє вашу відповідь.
# Реалізація
Після виклику lseek(fd, 3, SEEK_SET) покажчик встановлюється на 3-й байт файлу, де зберігається значення 2. Команда read(fd, buffer, 4) зчитує 4 байти, починаючи з цієї позиції: 2 (байт 3), 3 (байт 4), 3 (байт 5) і 7 (байт 6). У результаті буфер набуває значення {2, 3, 3, 7}.
 ```bash
yarik@FreeBSD:~/ASPZ/Practice 8 $ gcc -Wall task2.c -o task2
yarik@FreeBSD:~/ASPZ/Practice 8 $ ./task2
Buffer: 2 3 3 7 
yarik@FreeBSD:~/ASPZ/Practice 8 $
```
# Завдання 3
Бібліотечна функція qsort призначена для сортування даних будь-якого типу. Для її роботи необхідно підготувати функцію порівняння, яка викликається з qsort кожного разу, коли потрібно порівняти два значення.
Оскільки значення можуть мати будь-який тип, у функцію порівняння передаються два вказівники типу void* на елементи, що порівнюються.
Напишіть програму, яка досліджує, які вхідні дані є найгіршими для алгоритму швидкого сортування. Спробуйте знайти кілька масивів даних, які змушують qsort працювати якнайповільніше. Автоматизуйте процес експериментування так, щоб підбір і аналіз вхідних даних виконувалися самостійно.
Придумайте і реалізуйте набір тестів для перевірки правильності функції qsort.
# Реалізація
Аналіз результатів показує такі середні часи виконання:
— для зворотно відсортованих даних: приблизно 0.1–0.12 секунди;
— для однакових елементів: близько 0.04 секунди;
— для вже відсортованих даних: у межах 0.08–0.1 секунди;
— для випадкових даних: найдовше — приблизно 1.26–1.29 секунди.
 ```bash
yarik@FreeBSD:~/ASPZ/Practice 8 $ gcc -Wall task3.c -o task3
yarik@FreeBSD:~/ASPZ/Practice 8 $ ./task3
Reverse sorted       | Time: 0.10647  sec | PASS
Reverse sorted       | Time: 0.11457  sec | PASS
Reverse sorted       | Time: 0.11234  sec | PASS
All equal            | Time: 0.03906  sec | PASS
All equal            | Time: 0.03906  sec | PASS
All equal            | Time: 0.03906  sec | PASS
Already sorted       | Time: 0.10153  sec | PASS
Already sorted       | Time: 0.09366  sec | PASS
Already sorted       | Time: 0.07820  sec | PASS
Random data          | Time: 1.26678  sec | PASS
Random data          | Time: 1.28355  sec | PASS
Random data          | Time: 1.27135  sec | PASS
yarik@FreeBSD:~/ASPZ/Practice 8 $
```
# Завдання 4
Виконайте наступну програму на мові програмування С:
int main() {
  int pid;
  pid = fork();
  printf("%d\n", pid);
}
Завершіть цю програму. Припускаючи, що виклик fork() був успішним, яким може бути результат виконання цієї програми?
# Реалізація
Програма виведе два значення:
спочатку батьківський процес надрукує PID створеного дочірнього процесу (3677),
а потім сам дочірній процес виведе число 0.
 ```bash
yarik@FreeBSD:~/ASPZ/Practice 8 $ gcc -Wall task4.c -o task4
yarik@FreeBSD:~/ASPZ/Practice 8 $ ./task4
3677
0
yarik@FreeBSD:~/ASPZ/Practice 8 $
```
# Завдання 5(варіант 6)
Створіть експеримент, який показує вплив використання O_APPEND на поведінку write() у багатопроцесній програмі.
# Реалізація
Програма демонструє вплив використання прапора O_APPEND на безпечність запису у файл у багатопроцесному середовищі. Файл відкривається з O_APPEND або без нього залежно від аргументу користувача. Далі створюється кілька дочірніх процесів, кожен з яких записує у файл визначену кількість рядків. У режимі O_APPEND кожен виклик write() гарантує додавання до кінця файлу без конфліктів між процесами. Без O_APPEND позиція запису встановлюється вручну через lseek(), що призводить до можливих накладень і пошкодження даних. У завершенні програма аналізує вміст файлу, підраховує кількість рядків і виявляє пошкоджені (без символу нового рядка).
 ```bash
yarik@FreeBSD:~/ASPZ/Practice 8 $ gcc -Wall task6.c -o task6
yarik@FreeBSD:~/ASPZ/Practice 8 $ ./task6
PID parent = 3421  (O_APPEND)
Запис завершено. Перевіряємо файл…
Всього рядків: 5000, пошкоджених: 0
```
